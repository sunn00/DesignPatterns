<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script>
    function createPerson(name) {
      let o = {}
      o.name = name
      o.getName = function () {
        return o.name
      }

      return o
    }

    const person1 = createPerson('zhangsan')
    const person2 = createPerson('lisi')
    console.log(person1.name);
    console.log(person2.getName());
  </script>
</head>

<body>
  <h4>介绍</h4>
  <p>
    与创建型模式类似，工厂模式创建对象（视为工厂里的产品）时无需指定创建对象的具体类。
  </p>
  <p>
    工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。

  </p>
  <p>
    这个模式十分有用，尤其是创建对象的流程赋值的时候，比如依赖于很多设置文件等。并且，你会经常在程序里看到工厂方法，用于让子类类定义需要创建的对象类型。
  </p>

  <h4>使用场景</h4>
  以下几种情景下工厂模式特别有用：
  <ol>
    <li>对象的构建十分复杂</li>
    <li>需要依赖具体环境创建不同实例</li>
    <li>处理大量具有相同属性的小对象</li>
    <li>什么时候不该用工厂模式</li>
  </ol>
  不滥用运用工厂模式，有时候仅仅只是给代码增加了不必要的复杂度，同时使得测试难以运行下去。
</body>
</html>