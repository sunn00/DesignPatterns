<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script>
    /**
     * 背景： 卖车时如果要加配置则要加钱
    */

    // 非装饰器模式
    // function Car() {
    //   this.price = 10
    // }
    // Car.prototype = {
    //   addHeatSeat: function () {
    //     this.hasHeatSeat = true
    //     this.price += 2
    //   },
    //   addAutoMirror: function () {
    //     this.AutoMirror = true
    //     this.price += 0.8
    //   },
    // }

    // let car = new Car()
    // console.log(car.price);
    // car.addHeatSeat()
    // console.log(car.price);
    // car.addAutoMirror()
    // console.log(car.price);


    // 装饰器模式
    function Car() {
      this.price = 10
    }

    function carWithHeatSert(carClass) {
      carClass.hasHeatSeat = true
      carClass.price += 2
    }

    function carWithAutoMirror(carClass) {
      carClass.hasAutoMirror = true
      carClass.price += 0.8
    }

    const car1 = new Car()

    console.log(car1.price);
    carWithAutoMirror(car1);
    console.log(car1.price);
    // 优点： 不修改构造函数，只针对实例进行功能和实例的新增
  </script>
</head>

<body>
  <h4>介绍</h4>
  <p>
    装饰器模式，希望在不改变原对象的基础上，通过对其拓展功能和属性来实现更复杂的逻辑
  </p>
  <p>
    装饰者提供比继承更有弹性的替代方案。 装饰者用用于包装同接口的对象，不仅允许你向方法添加行为，而且还可以将方法设置成原始对象调用（例如装饰者的构造函数）。
    装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。
  </p>
  <p>
    当脚本运行时，在子类中增加行为会影响原有类所有的实例，而装饰者却不然。取而代之的是它能给不同对象各自添加新行为。
  </p>


  <h4>使用场景</h4>
  装饰者模式是为已有功能动态地添加更多功能的一种方式，把每个要装饰的功能放在单独的函数里，然后用该函数包装所要装饰的已有函数对象，因此，当需要执行特殊行为的时候，调用代码就可以根据需要有选择地、按顺序地使用装饰功能来包装对象。优点是把类（函数）的核心职责和装饰功能区分开了。

</body>

</html>